
           Паттерн "Адаптер":
           Цель: Создать класс обертку с требуемым интерфейсом,
                 который по сути транслирует свои запросы другому классу.
                 Иными словами, класс-оболочка оборачивает существующий класс,
                 чтобы придать ему нужный интерфейс, который хочет клиент.



           Реализация паттерна "Адаптер":
            1) Есть два класса с несовместимыми интерфейсами:
              1.1) Полезный сервис — служебный класс, который не можем изменять
                   (он либо сторонний, либо от него зависит другой код);
              1.2) Один или несколько клиентов — существующих классов приложения, несовместимых с сервисом
                   из-за неудобного или несовпадающего интерфейса.
            2) Описать клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
            3) Создать класс адаптера, реализовав этот интерфейс.
            4) Поместить в адаптер поле, которое будет хранить ссылку на объект сервиса.
               Обычно это поле заполняют объектом, переданным в конструктор адаптера.
               В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
            5) Реализовать все методы клиентского интерфейса в адаптере.
               Адаптер должен делегировать основную работу сервису.
            6) Приложение должно использовать адаптер только через клиентский интерфейс.
               Это позволит легко изменять и добавлять адаптеры в будущем.

           Применимость:
            1) Когда необходимо использовать сторонний класс,
               но его интерфейс не соответствует остальному коду приложения.
               Адаптер позволяет создать объект-прокладку, который будет превращать
               вызовы приложения в формат, понятный стороннему классу.
            2) Когда  нужно использовать несколько существующих подклассов,
               но в них не хватает какой-то общей функциональности,
               причём расширить суперкласс нет возможности.
               Можно создать ещё один уровень подклассов и добавить в них недостающую функциональность.
               Но при этом придётся дублировать один и тот же код в обеих ветках подклассов.