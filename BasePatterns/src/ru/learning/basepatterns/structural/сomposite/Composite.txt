
           Паттерн "Компоновщик":
           Цель: Создать интерфейс, который позволит сгруппировать множество объектов в древовидную структуру,
                 а затем работать с ней так, как будто это единичный объект.

           Реализация паттерна "Компоновщик":
            1) Убедится, что бизнес-логику можно представить как древовидную структуру.
               Разбить её на простые компоненты и контейнеры.
               Контейнеры могут содержать как простые компоненты, так и другие вложенные контейнеры.
            2) Создать общий интерфейс компонентов, который объединит операции контейнеров
               и простых компонентов дерева. Интерфейс будет удачным, если можно использовать его,
               чтобы взаимозаменять простые и составные компоненты без потери смысла.
            3) Создать класс компонентов-листьев, не имеющих дальнейших ответвлений.
               Иметь в виду, что программа может содержать несколько таких классов.
            4) Создать класс компонентов-контейнеров и добавить в него массив для хранения ссылок
               на вложенные компоненты. Этот массив должен быть способен содержать как простые,
               так и составные компоненты, поэтому необходимо убедится, что он объявлен с типом интерфейса компонентов.
                4.1) Реализовать в контейнере методы интерфейса компонентов, помня о том,
                     что контейнеры должны делегировать основную работу своим дочерним компонентам.
            5) Добавить операции добавления и удаления дочерних компонентов в класс контейнеров.
                5.1) Методы добавления/удаления дочерних компонентов можно поместить
                     и в интерфейс компонентов. Это нарушит принцип разделения интерфейса, так как реализации методов
                     будут пустыми в компонентах-листьях. Но зато все компоненты дерева станут
                     действительно одинаковыми для клиента.

           Применимость:
            1) Когда нужно представить древовидную структуру объектов.
               Паттерн Компоновщик предлагает хранить в составных объектах ссылки
               на другие простые или составные объекты.
               Те, в свою очередь, тоже могут хранить свои вложенные объекты и так далее.
               В итоге можно строить сложную древовидную структуру данных, используя всего
               две основные разновидности объектов.
            2) Когда клиенты должны единообразно трактовать простые и составные объекты.
               Благодаря тому, что простые и составные объекты реализуют общий интерфейс,
               клиенту безразлично, с каким именно объектом ему предстоит работать.
