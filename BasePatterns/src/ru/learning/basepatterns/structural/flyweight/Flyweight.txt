
           Паттерн "Приспособленец":
           Цель: Создать класс, который позволяет использовать
                 разделяемые объекты сразу в нескольких контекстах.
                 Данный паттерн используется преимущественно для оптимизации работы с памятью.


                 Flyweight дополняет шаблон Factory Method таким образом,
                 что при обращении клиента к Factory Method для создания нового объекта
                 ищет уже созданный объект с такими же параметрами, что и у требуемого,
                 и возвращает его клиенту. Если такого объекта нет, то фабрика создаст новый.

           Реализация паттерна "Приспособленец":
            1) Разделить поля класса, который станет легковесом, на две части:
               1.1) Внутреннее состояние: значения этих полей одинаковы для большого числа объектов;
               1.2) Внешнее состояние (контекст): значения полей уникальны для каждого объекта.
            2) Оставить поля внутреннего состояния в классе, но убедится, что их значения неизменяемы.
               Эти поля должны инициализироваться только через конструктор.
            3) Превратить поля внешнего состояния в параметры методов,
               где эти поля использовались. Затем удалить поля из класса.
            4) Создать фабрику, которая будет кешировать и повторно отдавать уже созданные объекты.
               Клиент должен запрашивать из этой фабрики легковеса с определённым внутренним состоянием,
               а не создавать его напрямую.
            5) Клиент должен хранить или вычислять значения внешнего состояния (контекст)
               и передавать его в методы объекта легковеса.

           Применимость:
            1) Когда не хватает оперативной памяти для поддержки всех нужных объектов.
               Эффективность паттерна Легковес во многом зависит от того, как и где он используется.
               Применять этот паттерн, когда выполнены все перечисленные условия:
                - в приложении используется большое число объектов;
                - из-за этого высоки расходы оперативной памяти;
                - большую часть состояния объектов можно вынести за пределы их классов;
                - большие группы объектов можно заменить относительно небольшим количеством разделяемых объектов,
                  поскольку внешнее состояние вынесено.
